import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { db } from '@/db';
import { pmSchedules, pmTemplates, locations, assets, tickets } from '@/db/schema';
import { eq, ilike, and, desc, asc, or, isNull } from 'drizzle-orm';
import { auth } from '@/lib/auth';

// Validation schemas
const pmScheduleCreateSchema = z.object({
    name: z.string().min(1, 'Schedule name is required').max(200, 'Name too long'),
    description: z.string().optional(),
    templateId: z.string().uuid('Invalid template ID'),
    locationId: z.string().uuid('Invalid location ID'),
    assetId: z.string().uuid('Invalid asset ID').optional(),
    recurrencePattern: z.enum(['daily', 'weekly', 'monthly', 'quarterly', 'yearly']),
    recurrenceInterval: z.number().int().min(1, 'Recurrence interval must be positive').default(1),
    startDate: z.string().datetime('Invalid start date'),
    endDate: z.string().datetime('Invalid end date').optional(),
    preferredTime: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format (HH:MM)').optional(),
    preferredDays: z.string().optional(), // JSON array
    businessDaysOnly: z.boolean().default(true),
    preferredTechnicianId: z.string().uuid().optional(),
    requiredSkills: z.string().optional(), // JSON array
    estimatedDurationMinutes: z.number().int().min(1).optional(),
    autoGenerateDays: z.number().int().min(1).max(365).default(30),
    generateOnWeekends: z.boolean().default(false),
    skipOnHolidays: z.boolean().default(true),
});

const pmScheduleUpdateSchema = pmScheduleCreateSchema.partial();

const pmScheduleQuerySchema = z.object({
    page: z.string().transform(Number).pipe(z.number().int().positive().default(1)),
    limit: z.string().transform(Number).pipe(z.number().int().positive().max(100).default(20)),
    search: z.string().optional(),
    templateId: z.string().uuid().optional(),
    locationId: z.string().uuid().optional(),
    assetId: z.string().uuid().optional(),
    recurrencePattern: z.enum(['daily', 'weekly', 'monthly', 'quarterly', 'yearly']).optional(),
    isActive: z.string().transform(Boolean).pipe(z.boolean().default(true)),
    sortBy: z.enum(['name', 'startDate', 'nextRun', 'createdAt', 'updatedAt']).default('nextRun'),
    sortOrder: z.enum(['asc', 'desc']).default('asc'),
    includeTemplate: z.string().transform(Boolean).pipe(z.boolean().default(false)),
    includeLocation: z.string().transform(Boolean).pipe(z.boolean().default(false)),
    includeAsset: z.string().transform(Boolean).pipe(z.boolean().default(false)),
    includeNextRun: z.string().transform(Boolean).pipe(z.boolean().default(true)),
    includeTicketCount: z.string().transform(Boolean).pipe(z.boolean().default(false)),
});

// Helper function to check permissions
async function checkPermission(action: 'create' | 'read' | 'update' | 'delete', request: NextRequest) {
    const session = await auth.api.getSession({
        headers: request.headers,
    });

    if (!session?.user) {
        return { authorized: false, error: 'Unauthorized' };
    }

    // For now, allow all authenticated users to read schedules
    if (action === 'read') {
        return { authorized: true, user: session.user };
    }

    if (action === 'create' || action === 'update' || action === 'delete') {
        // TODO: Implement proper role-based authorization (require admin or supervisor)
        // For now, allow all authenticated users
        return { authorized: true, user: session.user };
    }

    return { authorized: false, error: 'Insufficient permissions' };
}

// Helper function to calculate next run date
function calculateNextRun(schedule: any): Date | null {
    if (!schedule.isActive || schedule.pausedUntil && new Date(schedule.pausedUntil) > new Date()) {
        return null;
    }

    const now = new Date();
    const startDate = new Date(schedule.startDate);
    const endDate = schedule.endDate ? new Date(schedule.endDate) : null;

    // If schedule hasn't started yet
    if (startDate > now) {
        return startDate;
    }

    // If schedule has ended
    if (endDate && endDate < now) {
        return null;
    }

    // Calculate next run based on recurrence pattern
    let nextRun = new Date(startDate);

    while (nextRun <= now) {
        switch (schedule.recurrencePattern) {
            case 'daily':
                nextRun.setDate(nextRun.getDate() + schedule.recurrenceInterval);
                break;
            case 'weekly':
                nextRun.setDate(nextRun.getDate() + (7 * schedule.recurrenceInterval));
                break;
            case 'monthly':
                nextRun.setMonth(nextRun.getMonth() + schedule.recurrenceInterval);
                break;
            case 'quarterly':
                nextRun.setMonth(nextRun.getMonth() + (3 * schedule.recurrenceInterval));
                break;
            case 'yearly':
                nextRun.setFullYear(nextRun.getFullYear() + schedule.recurrenceInterval);
                break;
        }

        // Check if next run exceeds end date
        if (endDate && nextRun > endDate) {
            return null;
        }
    }

    // Apply business days only filter
    if (schedule.businessDaysOnly) {
        while (nextRun.getDay() === 0 || nextRun.getDay() === 6) { // Sunday or Saturday
            nextRun.setDate(nextRun.getDate() + 1);
        }
    }

    return nextRun;
}

// Helper function to generate tickets from schedule
async function generateTicketsFromSchedule(scheduleId: string, daysAhead: number = 30) {
    const schedule = await db
        .select()
        .from(pmSchedules)
        .where(eq(pmSchedules.id, scheduleId))
        .limit(1);

    if (schedule.length === 0 || !schedule[0].isActive) {
        return { generated: 0, message: 'Schedule not found or inactive' };
    }

    const scheduleData = schedule[0];
    const nextRun = calculateNextRun(scheduleData);

    if (!nextRun) {
        return { generated: 0, message: 'No upcoming runs for this schedule' };
    }

    // Check if tickets already exist for the next run
    const existingTickets = await db
        .select()
        .from(tickets)
        .where(and(
            eq(tickets.pmScheduleId, scheduleId),
            // Note: This would need proper date comparison
        ));

    // Generate tickets for all runs within the specified period
    const generatedTickets = [];
    const now = new Date();
    const cutoffDate = new Date(now.getTime() + (daysAhead * 24 * 60 * 60 * 1000));

    let runDate = nextRun;
    while (runDate <= cutoffDate) {
        // Check if ticket already exists for this run
        const runDateStr = runDate.toISOString().split('T')[0];
        const ticketExists = existingTickets.some(ticket =>
            ticket.pmDueDate && ticket.pmDueDate.toISOString().split('T')[0] === runDateStr
        );

        if (!ticketExists) {
            const ticketData = {
                title: `PM: ${scheduleData.name}`,
                description: scheduleData.description || `Scheduled maintenance for ${scheduleData.name}`,
                category: 'pm' as const,
                priorityLevel: 3, // Medium priority for PM
                locationId: scheduleData.locationId,
                assetId: scheduleData.assetId || null,
                requesterId: scheduleData.createdBy,
                requesterName: 'System Scheduler',
                assignedToId: scheduleData.preferredTechnicianId || null,
                assignedToName: scheduleData.preferredTechnicianId ? 'Assigned Technician' : null,
                pmScheduleId: scheduleId,
                pmTemplateId: scheduleData.templateId,
                pmDueDate: runDate,
                status: 'open' as const,
                workflowState: 'open' as const,
                reportedAt: new Date(),
                createdBy: scheduleData.createdBy,
                updatedBy: scheduleData.createdBy,
                isActive: true,
            };

            const createdTicket = await db.insert(tickets).values(ticketData).returning();
            generatedTickets.push(createdTicket[0]);
        }

        // Calculate next run
        switch (scheduleData.recurrencePattern) {
            case 'daily':
                runDate.setDate(runDate.getDate() + scheduleData.recurrenceInterval);
                break;
            case 'weekly':
                runDate.setDate(runDate.getDate() + (7 * scheduleData.recurrenceInterval));
                break;
            case 'monthly':
                runDate.setMonth(runDate.getMonth() + scheduleData.recurrenceInterval);
                break;
            case 'quarterly':
                runDate.setMonth(runDate.getMonth() + (3 * scheduleData.recurrenceInterval));
                break;
            case 'yearly':
                runDate.setFullYear(runDate.getFullYear() + scheduleData.recurrenceInterval);
                break;
        }
    }

    return { generated: generatedTickets.length, tickets: generatedTickets };
}

// GET - List PM schedules with filtering and pagination
export async function GET(request: NextRequest) {
    try {
        const permission = await checkPermission('read', request);
        if (!permission.authorized) {
            return NextResponse.json({ error: permission.error }, { status: 401 });
        }

        const { searchParams } = new URL(request.url);
        const query = pmScheduleQuerySchema.parse(Object.fromEntries(searchParams));

        // Build the query
        let conditions = [];

        if (query.search) {
            conditions.push(
                or(
                    ilike(pmSchedules.name, `%${query.search}%`),
                    ilike(pmSchedules.description, `%${query.search}%`)
                )
            );
        }

        if (query.templateId) {
            conditions.push(eq(pmSchedules.templateId, query.templateId));
        }

        if (query.locationId) {
            conditions.push(eq(pmSchedules.locationId, query.locationId));
        }

        if (query.assetId) {
            conditions.push(eq(pmSchedules.assetId, query.assetId));
        }

        if (query.recurrencePattern) {
            conditions.push(eq(pmSchedules.recurrencePattern, query.recurrencePattern));
        }

        conditions.push(eq(pmSchedules.isActive, query.isActive));

        const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

        // Get total count
        const totalCountResult = await db
            .select({ count: pmSchedules.id })
            .from(pmSchedules)
            .where(whereClause);
        const totalCount = totalCountResult.length;

        // Calculate pagination
        const offset = (query.page - 1) * query.limit;
        const totalPages = Math.ceil(totalCount / query.limit);

        // Build the main query
        let selectQuery = db.select().from(pmSchedules).where(whereClause);

        // Add ordering
        const orderByColumn = pmSchedules[query.sortBy as keyof typeof pmSchedules];
        const orderDirection = query.sortOrder === 'asc' ? asc : desc;
        selectQuery = selectQuery.orderBy(orderDirection(orderByColumn));

        // Add pagination
        selectQuery = selectQuery.limit(query.limit).offset(offset);

        const schedulesData = await selectQuery;

        // Include related data if requested
        let result = schedulesData;
        if (query.includeTemplate || query.includeLocation || query.includeAsset ||
            query.includeNextRun || query.includeTicketCount) {
            result = await Promise.all(
                schedulesData.map(async (schedule) => {
                    let enrichedSchedule = { ...schedule };

                    if (query.includeTemplate) {
                        const templateData = await db
                            .select()
                            .from(pmTemplates)
                            .where(eq(pmTemplates.id, schedule.templateId))
                            .limit(1);

                        enrichedSchedule.template = templateData[0] || null;
                    }

                    if (query.includeLocation) {
                        const locationData = await db
                            .select()
                            .from(locations)
                            .where(eq(locations.id, schedule.locationId))
                            .limit(1);

                        enrichedSchedule.location = locationData[0] || null;
                    }

                    if (query.includeAsset && schedule.assetId) {
                        const assetData = await db
                            .select()
                            .from(assets)
                            .where(eq(assets.id, schedule.assetId))
                            .limit(1);

                        enrichedSchedule.asset = assetData[0] || null;
                    }

                    if (query.includeNextRun) {
                        const nextRun = calculateNextRun(schedule);
                        enrichedSchedule.nextRun = nextRun;
                        enrichedSchedule.daysUntilNextRun = nextRun
                            ? Math.ceil((nextRun.getTime() - Date.now()) / (1000 * 60 * 60 * 24))
                            : null;
                    }

                    if (query.includeTicketCount) {
                        const ticketCount = await db
                            .select({ count: tickets.id })
                            .from(tickets)
                            .where(and(
                                eq(tickets.pmScheduleId, schedule.id),
                                eq(tickets.category, 'pm')
                            ));

                        enrichedSchedule.ticketCount = ticketCount.length;
                    }

                    return enrichedSchedule;
                })
            );
        }

        // Response headers for pagination
        const headers = new Headers({
            'X-Total-Count': totalCount.toString(),
            'X-Total-Pages': totalPages.toString(),
            'X-Current-Page': query.page.toString(),
            'X-Per-Page': query.limit.toString(),
        });

        return NextResponse.json({
            data: result,
            pagination: {
                currentPage: query.page,
                totalPages,
                totalCount,
                perPage: query.limit,
                hasNextPage: query.page < totalPages,
                hasPreviousPage: query.page > 1,
            },
        }, { headers });

    } catch (error) {
        console.error('Error fetching PM schedules:', error);

        if (error instanceof z.ZodError) {
            return NextResponse.json({
                error: 'Invalid query parameters',
                details: error.errors
            }, { status: 400 });
        }

        return NextResponse.json({
            error: 'Failed to fetch PM schedules'
        }, { status: 500 });
    }
}

// POST - Create new PM schedule
export async function POST(request: NextRequest) {
    try {
        const permission = await checkPermission('create', request);
        if (!permission.authorized) {
            return NextResponse.json({ error: permission.error }, { status: 401 });
        }

        const body = await request.json();
        const validatedData = pmScheduleCreateSchema.parse(body);

        // Validate template exists
        const templateExists = await db
            .select()
            .from(pmTemplates)
            .where(eq(pmTemplates.id, validatedData.templateId))
            .limit(1);

        if (templateExists.length === 0) {
            return NextResponse.json({
                error: 'PM template not found'
            }, { status: 400 });
        }

        // Validate location exists
        const locationExists = await db
            .select()
            .from(locations)
            .where(eq(locations.id, validatedData.locationId))
            .limit(1);

        if (locationExists.length === 0) {
            return NextResponse.json({
                error: 'Location not found'
            }, { status: 400 });
        }

        // Validate asset if provided
        if (validatedData.assetId) {
            const assetExists = await db
                .select()
                .from(assets)
                .where(and(
                    eq(assets.id, validatedData.assetId),
                    eq(assets.locationId, validatedData.locationId)
                ))
                .limit(1);

            if (assetExists.length === 0) {
                return NextResponse.json({
                    error: 'Asset not found or does not belong to specified location'
                }, { status: 400 });
            }
        }

        // Validate dates
        const startDate = new Date(validatedData.startDate);
        const endDate = validatedData.endDate ? new Date(validatedData.endDate) : null;

        if (endDate && endDate <= startDate) {
            return NextResponse.json({
                error: 'End date must be after start date'
            }, { status: 400 });
        }

        // Create the schedule
        const newSchedule = {
            ...validatedData,
            startDate,
            endDate,
            createdBy: permission.user.id,
            updatedBy: permission.user.id,
        };

        const result = await db
            .insert(pmSchedules)
            .values(newSchedule)
            .returning();

        // Optionally generate tickets immediately if requested
        const { searchParams } = new URL(request.url);
        if (searchParams.get('generateImmediate') === 'true') {
            const generationResult = await generateTicketsFromSchedule(result[0].id);

            return NextResponse.json({
                message: 'PM schedule created successfully',
                data: result[0],
                ticketGeneration: generationResult,
            }, { status: 201 });
        }

        return NextResponse.json({
            message: 'PM schedule created successfully',
            data: result[0],
        }, { status: 201 });

    } catch (error) {
        console.error('Error creating PM schedule:', error);

        if (error instanceof z.ZodError) {
            return NextResponse.json({
                error: 'Invalid request data',
                details: error.errors
            }, { status: 400 });
        }

        return NextResponse.json({
            error: 'Failed to create PM schedule'
        }, { status: 500 });
    }
}